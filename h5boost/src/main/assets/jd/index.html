<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0">
    <title>京东商城</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<script src="js/index.js"></script>
<body>
<!--header-->
<header id="header">
    <section class="search-bar">
        <div class="container">
                <span class="jd-search-logo">
                <i class="jd-sprite-search-logo"></i>
            </span>
            <form action="">
                <input type="search" placeholder="把年货带回家" class="input-search">
                <i class="jd-sprite-input-icon"></i>
            </form>
            <a href="#" class="login">登录</a>
        </div>
    </section>
    <div class="container">
        <section class="slider">
            <ul class="slider-wrapper">
                <!--slider-->
            </ul>
            <ul class="indicators">
                <li class="indicators-item"></li>
                <li class="indicators-item"></li>
                <li class="indicators-item"></li>
                <li class="indicators-item"></li>
                <li class="indicators-item"></li>
                <li class="indicators-item"></li>
            </ul>
        </section>
        <nav class="nav clearfix">
            <ul class="nav-wrapper">
                <!--navigation-->
            </ul>
        </nav>
    </div>
</header>
<!--header-->
<!--main-->
<main id="main">
    <div class="container">
        <section id="secKill">
            <div class="top clearfix">
                <div class="more pull-right">
                    <a href="#">更多></a>
                </div>
                <i class="jd-icon-seckill pull-left"></i>
                <span>掌上秒杀</span>
                <div class="count-down">
                    <span class="number">0</span>
                    <span class="number">1</span>
                    <span>:</span>
                    <span class="number">3</span>
                    <span class="number">3</span>
                    <span>:</span>
                    <span class="number">2</span>
                    <span class="number">9</span>
                </div>
            </div>
            <ul class="products clearfix">
                <li class="pull-left">
                    <a href="#">
                        <div class="image-box">
                            <img src="images/detail02.jpg" alt="">
                        </div>
                        <p>¥20.00</p>
                        <p>¥200.00</p>
                    </a>
                </li>
                <li class="pull-left">
                    <a href="#">
                        <div class="image-box">
                            <img src="images/detail02.jpg" alt="">
                        </div>
                        <p>¥20.00</p>
                        <p>¥200.00</p>
                    </a>
                </li>
                <li class="pull-left">
                    <a href="#">
                        <div class="image-box">
                            <img src="images/detail02.jpg" alt="">
                        </div>
                        <p>¥20.00</p>
                        <p>¥200.00</p>
                    </a>
                </li>
            </ul>
        </section>
        <section id="cheapBuy">
            <p>
                这里主要有两条并行线，左边是webview的执行流程，右边是sonic的执行流程。Webview的执行流程比较简单，主要是进行webview的初始化，以及在初始化完之后调用SonicSession（这里的SonicSession对象是activity onCreate的时候通过SonicEngine创建的）的onClientReady方法，告知其webview已经init完毕。剩下的事情交给sonic那边处理。

                右边这条sonic的执行流程线相对会复杂一些，首先，在activity create之后通过SonicEngine创建SonicSession对象。接着调用SonicCacheInterceptor来获取本地缓存的url对应的数据。由于是首次加载即本地无缓存数据，所以这里的数据是为空的。获取的数据为空之后会post一个CLIENT_CORE_MSG_PRE_LOAD(arg1 = PRE_LOAD_NO_CACHE )的消息到主线程中，同时继续执行下面的逻辑。主线程的逻辑后面统一分析，这里先分析sonic所在子线程中的逻辑。

                Sonic在post消息到主线程之后会通过SonicSessionConnection建立一个URLConnection，接着通过这个连接获取服务器返回的数据。由于获取网络数据是个耗时的过程，所以在读取网络数据的过程中会不断的判断webView是否发起资源拦截请求（通过SonicSession的wasInterceptInvoked来判断），如果webview已经发起资源拦截请求，就中断网络数据的读取，将已经读取的数据和未读取的网络数据拼接成桥接流SonicSessionStream，并将其赋值给SonicSession的pendingWebResourceStream。如果整个网络数据读取完毕之后webview还没有初始化完，那么就会把之前post的CLIENT_CORE_MSG_PRE_LOAD的消息cancel调。同时post一个CLIENT_CORE_MSG_FIRST_LOAD的消息到主线程。之后再对html内容进行模版分割及数据保存。

                接下来看看主线程的执行逻辑。之前说过sonic在本地无缓存的时候会先post一个CLIENT_CORE_MSG_PRE_LOAD的消息到主线程，如果主线程有执行到这个消息的话（之前也介绍过这个消息有可能被cancel掉）就会调用webview的loadUrl，发起真正的网络请求，之后webview会调用本身的资源拦截方法，在这个方法中sonic会将之前保存的pendingWebResourceStream返回给webview，有了这个pendingWebResourceStream之后webview就可以进行解析渲染逻辑了。同时webview在展示完页面之后会调SonicSessionStream的onClose方法进行关闭数据流，在这个onClose中我们会进行html内容的数据分割以及数据保存操作。

                如果主线程处理的是CLIENT_CORE_MSG_FIRST_LOAD消息，则会先判断webview之前是否有发生过loadUrl（通过wasLoadUrlInvoked来判断），如果没有，调用webview的loadDataWithBaseUrl方法去加载之前读取的网络数据，这样webview就可以根据这个数据直接做解析渲染的逻辑了；如果有就不做任何的逻辑处理了。

                以上就是在quick模式下sonic首次的基本逻辑。这里有个问题要注意，就是主线程在处理sonic post的消息之前都会判断webview是否ready（初始化完毕），只有webview ready的情况才会执行对应的操作。如果webview没有ready的话就会把对应的消息存起来，直到webview ready的时候再执行对应的逻辑。
            </p>
        </section>
    </div>
</main>
<!--main-->
<footer></footer>

</body>
</html>